{"posts":[{"title":"代码源div2每日一题 最喜欢数学了（高数除外）","content":"题面 小明的数学很好，所以他认为世界上所有的数学问题都很简单。 但是有一天，他遇到了一个他无法解决的数学问题，所以他请求你帮助他。 小明会给你两个数字 𝑎 和 𝑏 ，然后你应该选择一个正奇数 𝑥 和一个正偶数 𝑦 ，你可以让 𝑎 加上 𝑥 或让 𝑎 减去 𝑦，在一次运算中。你应该在最少的操作中把 𝑎 变成 𝑏。请注意，在同一次运算中，你不允许改变 𝑥 和 𝑦 的值。 输入格式 在第一行，有一个整数 𝑇。 接下来 𝑇 行每行2个整数 𝑎、𝑏。表示由小明给出的数字。 输出格式 一个数，表示将 𝑎 变为 𝑏 所需的最小操作数。 样例输入 1 10 7 样例输出 2 数据规模 所有数据保证 1≤𝑇≤105,1≤𝑎,𝑏≤106。 题解 对于任意的a, b。我们可以分为三种情况来讨论： a &lt; b. 对于任意的a &lt; b，当b-a的值为奇数，那么很显然1次操作就能使a变成b；当b-a为偶数，那么又可以分为((b-a)/2)为偶数和((b-a)/2)为奇数，当情况为前者的时候，这时我们可以先加上一个奇数再减去一个偶数再加上一个奇数，例如：2 34，我们可以让2+35-38+3 = 34. 而且没有其他操作能同样满足条件并且操作数比3小，所以此时答案为3；当情况为后者的时候，显然我们可以加上两个奇数就可以做到，例如：10 48， 我们让10+19+19，此时答案为2； a &gt; b. 这种情况比较简单，若a与b奇偶性相同，则答案为1，否则为2. a = b. 0次操作。 #include &lt;bits/stdc++.h&gt; #define rep(i,l,n) for(int i = (int)l; i &lt; (int)n; i++) #define PII std::pair&lt;int, int&gt; #define pb push_back #define FAST std::cin.tie(nullptr)-&gt;std::ios_base::sync_with_stdio(false) #define all(x) (x).begin(), (x).end() #define edl std::cout &lt;&lt; '\\n'; #define fi first #define se second #define debug(a) std::cout &lt;&lt; #a &lt;&lt; &quot; = &quot; &lt;&lt; (a) &lt;&lt; '\\n'; #define inf 0x3c3c3c3c // 1010580540, 7f7f7f7f:2139062143 #define llinf 9223372036854775807 #define cmuticases() int T;scanf(&quot;%d&quot;,&amp;T);while(T--)solve(); #define muticases() int T;std::cin&gt;&gt;T;while(T--)solve(); std::mt19937_64 mrand(std::random_device{}()); using ll = long long; using ull = unsigned long long; const ll mod=998244353; int rnd(int x) { return mrand() % x;} ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;} ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;} //using namespace std; //#define int long long inline void solve() { int a, b; std::cin &gt;&gt; a &gt;&gt; b; if(a &lt; b) { if((b - a) % 2 == 1) std::cout &lt;&lt; &quot;1\\n&quot;; else { int res = ((b-a)/2)%2; if(res == 1) std::cout &lt;&lt; &quot;2\\n&quot;; else std::cout &lt;&lt; &quot;3\\n&quot;; } } else if(a &gt; b) { if(a%2 == b%2) std::cout &lt;&lt; &quot;1\\n&quot;; else std::cout &lt;&lt; &quot;2\\n&quot;; } else std::cout &lt;&lt; &quot;0\\n&quot;; } int main() { FAST; muticases(); return 0; } ","link":"https://iceboyzz.github.io/post/dai-ma-yuan-div2-mei-ri-yi-ti-zui-xi-huan-shu-xue-liao-gao-shu-chu-wai/"},{"title":"关于","content":" 大二在读 关于本站 分享一些日常 ","link":"https://iceboyzz.github.io/post/about/"},{"title":"代码源div2每日一题 农田划分","content":"题目链接 题目描述 约翰是一个农场主，他的农场有n块田，编号从 1到 𝑛，这 𝑛块田通过 𝑚条双向道路相连(数据保证这n块田都是联通的)，我们假设第𝑖块田会产生 2𝑖kg 的收益，现在约翰想把农田的工作全部交给自己的两个孩子，划分方式必须满足以下规则: 1.每一块田都需要恰好被分给一个孩子. 2.分给两个孩子的农田必须是联通的.就是说对于任意一个孩子在划分给自己的任意一块田，都可以不经过另外一个孩子的田，到达自己的任意一块田. 3.划分给两个孩子的收益必须尽可能的相等，如果无法相等，年长的孩子会得到大的那一份. 对于第 𝑖块田，如果你要把它分给年长的孩子，请输出A,否则输出B. 题目输入 第一行输入两个整数分别代表 𝑛,𝑚 接下来 𝑚行，每个两个整数𝑢,𝑣，代表这两块农田通过一条双向道路直接相连，数据保证没有重边和自环 题目输出 输出一个字符串，代表答案 样例输入1 3 2 1 3 3 2 样例输出1 ABA 样例输入2 6 6 3 5 2 6 1 3 3 6 5 1 4 6 样例输出2 BABABA 数据范围 2≤𝑛≤3𝑒5,1≤𝑚≤3𝑒5 题解 由于每块田都需要被分配到哥哥或者弟弟名下，而且点权为2^i。并且要求两者获得的收益：sumO &gt;= sumY, 可以发现，假如最后一块土地分给哥哥，那么无论弟弟分到多少土地，其点权和都不会超过哥哥，所以我们可以对于点n-1开始搜索，对于所有与n-1连通的点都把这个点的值设为'B'，其他的点设为'A'。 标签 DFS 并查集 图 题解 #include &lt;bits/stdc++.h&gt; #define rep(i,l,n) for(int i = (int)l; i &lt; (int)n; i++) #define PII std::pair&lt;int, int&gt; #define pb push_back #define FAST std::cin.tie(nullptr)-&gt;std::ios_base::sync_with_stdio(false) #define all(x) (x).begin(), (x).end() #define edl std::cout &lt;&lt; '\\n'; #define fi first #define se second #define debug(a) cout &lt;&lt; #a &lt;&lt; &quot; = &quot; &lt;&lt; (a) &lt;&lt; '\\n'; #define inf 0x3c3c3c3c // 1010580540, 7f7f7f7f:2139062143 #define llinf 9223372036854775807 #define cmuticases() int T;scanf(&quot;%d&quot;,&amp;T);while(T--) solve(); #define muticases() int T;std::cin&gt;&gt;T;while(T--)solve(); std::mt19937_64 mrand(std::random_device{}()); //using namespace std; using ll = long long; using ull = unsigned long long; //#define int long long const int N = 3e5+10; std::vector&lt;int&gt; g[N]; char a[N]; bool vis[N]; int n, m; inline void dfs(int x) { vis[x] = true; a[x] = 'B'; for (auto to : g[x]) if(!vis[to] &amp;&amp; to != n) dfs(to); } int main() { FAST; std::cin &gt;&gt; n &gt;&gt; m; while(m--) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; g[u].pb(v); g[v].pb(u); } memset(vis, false, sizeof vis); rep(i,1,n+1) a[i] = 'A'; dfs(n-1); rep(i,1,n+1) std::cout &lt;&lt; a[i]; return 0; } ","link":"https://iceboyzz.github.io/post/dai-ma-yuan-div2-mei-ri-yi-ti-nong-tian-hua-fen/"}]}